# <a name="exceptions"></a><span data-ttu-id="e9767-101">Exceptions</span><span class="sxs-lookup"><span data-stu-id="e9767-101">Exceptions</span></span>

<span data-ttu-id="e9767-102">C# 中的异常提供结构化、 统一的和类型安全方式来处理系统级别和应用程序级别的错误条件。</span><span class="sxs-lookup"><span data-stu-id="e9767-102">Exceptions in C# provide a structured, uniform, and type-safe way of handling both system level and application level error conditions.</span></span> <span data-ttu-id="e9767-103">在 C# 中的异常机制是非常类似于 c + +，有几个重要的区别：</span><span class="sxs-lookup"><span data-stu-id="e9767-103">The exception mechanism in C# is quite similar to that of C++, with a few important differences:</span></span>

*  <span data-ttu-id="e9767-104">在 C# 中，必须由派生自类类型的实例表示的所有异常`System.Exception`。</span><span class="sxs-lookup"><span data-stu-id="e9767-104">In C#, all exceptions must be represented by an instance of a class type derived from `System.Exception`.</span></span> <span data-ttu-id="e9767-105">在 c + +，可以使用任何类型的任何值表示该异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-105">In C++, any value of any type can be used to represent an exception.</span></span>
*  <span data-ttu-id="e9767-106">在 C# 中，finally 块 ([try 语句](statements.md#the-try-statement)) 可用于编写在正常执行和异常情况中执行的终止代码。</span><span class="sxs-lookup"><span data-stu-id="e9767-106">In C#, a finally block ([The try statement](statements.md#the-try-statement)) can be used to write termination code that executes in both normal execution and exceptional conditions.</span></span> <span data-ttu-id="e9767-107">此类代码不易编写 c + + 中，无需复制代码。</span><span class="sxs-lookup"><span data-stu-id="e9767-107">Such code is difficult to write in C++ without duplicating code.</span></span>
*  <span data-ttu-id="e9767-108">在 C# 中，系统级别的异常例如溢出、 被零除和 null 取消引用有明确定义的异常类，等同于应用程序级别的错误条件。</span><span class="sxs-lookup"><span data-stu-id="e9767-108">In C#, system-level exceptions such as overflow, divide-by-zero, and null dereferences have well defined exception classes and are on a par with application-level error conditions.</span></span>

## <a name="causes-of-exceptions"></a><span data-ttu-id="e9767-109">引发异常的原因</span><span class="sxs-lookup"><span data-stu-id="e9767-109">Causes of exceptions</span></span>

<span data-ttu-id="e9767-110">可以在两种不同方法中引发异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-110">Exception can be thrown in two different ways.</span></span>

*  <span data-ttu-id="e9767-111">一个`throw`语句 ([throw 语句](statements.md#the-throw-statement)) 立即无条件地将引发异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-111">A `throw` statement ([The throw statement](statements.md#the-throw-statement)) throws an exception immediately and unconditionally.</span></span> <span data-ttu-id="e9767-112">控件永远不会到达紧跟的语句`throw`。</span><span class="sxs-lookup"><span data-stu-id="e9767-112">Control never reaches the statement immediately following the `throw`.</span></span>
*  <span data-ttu-id="e9767-113">C# 语句和表达式的处理过程中出现特定异常情况时无法正常完成该操作，在某些情况下导致异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-113">Certain exceptional conditions that arise during the processing of C# statements and expression cause an exception in certain circumstances when the operation cannot be completed normally.</span></span> <span data-ttu-id="e9767-114">例如，整数除法运算 ([除法运算符](expressions.md#division-operator)) 将引发`System.DivideByZeroException`如果分母为零。</span><span class="sxs-lookup"><span data-stu-id="e9767-114">For example, an integer division operation ([Division operator](expressions.md#division-operator)) throws a `System.DivideByZeroException` if the denominator is zero.</span></span> <span data-ttu-id="e9767-115">请参阅[常见的异常类](exceptions.md#common-exception-classes)有关可在这种方式中出现的各种异常情况的列表。</span><span class="sxs-lookup"><span data-stu-id="e9767-115">See [Common Exception Classes](exceptions.md#common-exception-classes) for a list of the various exceptions that can occur in this way.</span></span>

## <a name="the-systemexception-class"></a><span data-ttu-id="e9767-116">System.Exception 类</span><span class="sxs-lookup"><span data-stu-id="e9767-116">The System.Exception class</span></span>

<span data-ttu-id="e9767-117">`System.Exception`类是所有异常的基类型。</span><span class="sxs-lookup"><span data-stu-id="e9767-117">The `System.Exception` class is the base type of all exceptions.</span></span> <span data-ttu-id="e9767-118">此类具有共享的所有异常的几个值得注意的属性：</span><span class="sxs-lookup"><span data-stu-id="e9767-118">This class has a few notable properties that all exceptions share:</span></span>

*  <span data-ttu-id="e9767-119">`Message` 是只读的属性类型的`string`，其中包含异常的原因的人工可读说明。</span><span class="sxs-lookup"><span data-stu-id="e9767-119">`Message` is a read-only property of type `string` that contains a human-readable description of the reason for the exception.</span></span>
*  <span data-ttu-id="e9767-120">`InnerException` 是只读的属性类型的`Exception`。</span><span class="sxs-lookup"><span data-stu-id="e9767-120">`InnerException` is a read-only property of type `Exception`.</span></span> <span data-ttu-id="e9767-121">如果其值为非 null，它引用导致当前异常的异常 — 也就是说，在 catch 块中引发当前异常处理`InnerException`。</span><span class="sxs-lookup"><span data-stu-id="e9767-121">If its value is non-null, it refers to the exception that caused the current exception—that is, the current exception was raised in a catch block handling the `InnerException`.</span></span> <span data-ttu-id="e9767-122">否则，其值为 null，指示此异常不由另一个异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-122">Otherwise, its value is null, indicating that this exception was not caused by another exception.</span></span> <span data-ttu-id="e9767-123">这种方式中链接在一起的异常对象的数目可以是任意的。</span><span class="sxs-lookup"><span data-stu-id="e9767-123">The number of exception objects chained together in this manner can be arbitrary.</span></span>

<span data-ttu-id="e9767-124">可以对的实例构造函数的调用中指定这些属性的值`System.Exception`。</span><span class="sxs-lookup"><span data-stu-id="e9767-124">The value of these properties can be specified in calls to the instance constructor for `System.Exception`.</span></span>

## <a name="how-exceptions-are-handled"></a><span data-ttu-id="e9767-125">如何处理异常</span><span class="sxs-lookup"><span data-stu-id="e9767-125">How exceptions are handled</span></span>

<span data-ttu-id="e9767-126">通过处理异常`try`语句 ([try 语句](statements.md#the-try-statement))。</span><span class="sxs-lookup"><span data-stu-id="e9767-126">Exceptions are handled by a `try` statement ([The try statement](statements.md#the-try-statement)).</span></span>

<span data-ttu-id="e9767-127">异常发生时，系统将搜索最近`catch`可以处理该异常，由该异常的运行时类型的子句。</span><span class="sxs-lookup"><span data-stu-id="e9767-127">When an exception occurs, the system searches for the nearest `catch` clause that can handle the exception, as determined by the run-time type of the exception.</span></span> <span data-ttu-id="e9767-128">首先，当前方法搜索的词法封闭`try`按顺序考虑语句和 try 语句相关联的 catch 子句。</span><span class="sxs-lookup"><span data-stu-id="e9767-128">First, the current method is searched for a lexically enclosing `try` statement, and the associated catch clauses of the try statement are considered in order.</span></span> <span data-ttu-id="e9767-129">如果该操作失败，搜索调用当前方法的方法从词法上封闭`try`对当前方法的调用点的语句。</span><span class="sxs-lookup"><span data-stu-id="e9767-129">If that fails, the method that called the current method is searched for a lexically enclosing `try` statement that encloses the point of the call to the current method.</span></span> <span data-ttu-id="e9767-130">此搜索将继续，直至`catch`子句找到能处理当前异常，通过命名的是同一个类或基类时，所引发的异常的运行时类型的异常类。</span><span class="sxs-lookup"><span data-stu-id="e9767-130">This search continues until a `catch` clause is found that can handle the current exception, by naming an exception class that is of the same class, or a base class, of the run-time type of the exception being thrown.</span></span> <span data-ttu-id="e9767-131">一个`catch`子句未命名的异常类可以处理任何异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-131">A `catch` clause that doesn't name an exception class can handle any exception.</span></span>

<span data-ttu-id="e9767-132">一旦找到匹配的 catch 子句，则系统将准备将控制转移到 catch 子句的第一个语句。</span><span class="sxs-lookup"><span data-stu-id="e9767-132">Once a matching catch clause is found, the system prepares to transfer control to the first statement of the catch clause.</span></span> <span data-ttu-id="e9767-133">Catch 子句的执行开始之前，系统首先，按顺序执行，任何`finally`子句与 try 语句更多相关联，嵌套的比捕获该异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-133">Before execution of the catch clause begins, the system first executes, in order, any `finally` clauses that were associated with try statements more nested that than the one that caught the exception.</span></span>

<span data-ttu-id="e9767-134">如果不找到任何匹配的 catch 子句，则会发生两个条件之一：</span><span class="sxs-lookup"><span data-stu-id="e9767-134">If no matching catch clause is found, one of two things occurs:</span></span>

*  <span data-ttu-id="e9767-135">如果对匹配的 catch 子句的搜索到达静态构造函数 ([静态构造函数](classes.md#static-constructors)) 或静态字段初始值设定项，则`System.TypeInitializationException`触发调用静态构造函数的时候引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-135">If the search for a matching catch clause reaches a static constructor ([Static constructors](classes.md#static-constructors)) or static field initializer, then a `System.TypeInitializationException` is thrown at the point that triggered the invocation of the static constructor.</span></span> <span data-ttu-id="e9767-136">内部异常的`System.TypeInitializationException`包含最初引发的异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-136">The inner exception of the `System.TypeInitializationException` contains the exception that was originally thrown.</span></span>
*  <span data-ttu-id="e9767-137">如果搜索匹配的 catch 子句达到最初启动该线程的代码，则终止线程的执行。</span><span class="sxs-lookup"><span data-stu-id="e9767-137">If the search for matching catch clauses reaches the code that initially started the thread, then execution of the thread is terminated.</span></span> <span data-ttu-id="e9767-138">此类终止的影响是实现定义的。</span><span class="sxs-lookup"><span data-stu-id="e9767-138">The impact of such termination is implementation-defined.</span></span>

<span data-ttu-id="e9767-139">析构函数执行过程中发生的异常是特别注意。</span><span class="sxs-lookup"><span data-stu-id="e9767-139">Exceptions that occur during destructor execution are worth special mention.</span></span> <span data-ttu-id="e9767-140">如果析构函数在执行期间，会发生异常，并且不捕获该异常，然后终止该析构函数的执行并调用 （如果有） 的基类的析构函数。</span><span class="sxs-lookup"><span data-stu-id="e9767-140">If an exception occurs during destructor execution, and that exception is not caught, then the execution of that destructor is terminated and the destructor of the base class (if any) is called.</span></span> <span data-ttu-id="e9767-141">如果没有基类 (一样的情况下`object`类型) 或如果没有基类的析构函数，则异常将被丢弃。</span><span class="sxs-lookup"><span data-stu-id="e9767-141">If there is no base class (as in the case of the `object` type) or if there is no base class destructor, then the exception is discarded.</span></span>

## <a name="common-exception-classes"></a><span data-ttu-id="e9767-142">常见的异常类</span><span class="sxs-lookup"><span data-stu-id="e9767-142">Common Exception Classes</span></span>

<span data-ttu-id="e9767-143">某些 C# 操作通过引发以下异常。</span><span class="sxs-lookup"><span data-stu-id="e9767-143">The following exceptions are thrown by certain C# operations.</span></span>

|                                      |                |
|--------------------------------------|----------------|
| `System.ArithmeticException`         | <span data-ttu-id="e9767-144">算术运算期间出现的异常的基类，例如 `System.DivideByZeroException` 和 `System.OverflowException`。</span><span class="sxs-lookup"><span data-stu-id="e9767-144">A base class for exceptions that occur during arithmetic operations, such as `System.DivideByZeroException` and `System.OverflowException`.</span></span> | 
| `System.ArrayTypeMismatchException`  | <span data-ttu-id="e9767-145">当为一个数组的存储会失败，因为存储的元素的实际类型与数组的实际类型不兼容时引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-145">Thrown when a store into an array fails because the actual type of the stored element is incompatible with the actual type of the array.</span></span> | 
| `System.DivideByZeroException`       | <span data-ttu-id="e9767-146">当尝试除以零的整数值时引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-146">Thrown when an attempt to divide an integral value by zero occurs.</span></span> | 
| `System.IndexOutOfRangeException`    | <span data-ttu-id="e9767-147">当尝试通过索引小于零或超出数组界限的数组编制索引时引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-147">Thrown when an attempt to index an array via an index that is less than zero or outside the bounds of the array.</span></span> | 
| `System.InvalidCastException`        | <span data-ttu-id="e9767-148">从基类或接口为派生类型的显式转换在运行时失败时引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-148">Thrown when an explicit conversion from a base type or interface to a derived type fails at run time.</span></span> | 
| `System.NullReferenceException`      | <span data-ttu-id="e9767-149">时引发`null`使引用的对象是所需的方式使用引用。</span><span class="sxs-lookup"><span data-stu-id="e9767-149">Thrown when a `null` reference is used in a way that causes the referenced object to be required.</span></span> | 
| `System.OutOfMemoryException`        | <span data-ttu-id="e9767-150">当尝试分配内存时引发 (通过`new`) 失败。</span><span class="sxs-lookup"><span data-stu-id="e9767-150">Thrown when an attempt to allocate memory (via `new`) fails.</span></span> | 
| `System.OverflowException`           | <span data-ttu-id="e9767-151">`checked` 上下文中的算术运算溢出时引发。</span><span class="sxs-lookup"><span data-stu-id="e9767-151">Thrown when an arithmetic operation in a `checked` context overflows.</span></span> | 
| `System.StackOverflowException`      | <span data-ttu-id="e9767-152">引发在执行堆栈用尽了的过多挂起的方法调用;通常指明可能出现了非常深度或无限递归。</span><span class="sxs-lookup"><span data-stu-id="e9767-152">Thrown when the execution stack is exhausted by having too many pending method calls; typically indicative of very deep or unbounded recursion.</span></span> | 
| `System.TypeInitializationException` | <span data-ttu-id="e9767-153">引发时，静态构造函数引发异常，但没有`catch`子句存在捕获它。</span><span class="sxs-lookup"><span data-stu-id="e9767-153">Thrown when a static constructor throws an exception, and no `catch` clauses exists to catch it.</span></span> | 
