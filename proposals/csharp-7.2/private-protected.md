---
ms.openlocfilehash: 6cf489595654236c18edee94c0af380e605c9571
ms.sourcegitcommit: f61a06970fa0562d2e40363fae3948eb168624ca
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 01/14/2020
ms.locfileid: "79484074"
---
# <a name="private-protected"></a><span data-ttu-id="cc7db-101">私有受保护</span><span class="sxs-lookup"><span data-stu-id="cc7db-101">private protected</span></span>

* <span data-ttu-id="cc7db-102">[x] 建议</span><span class="sxs-lookup"><span data-stu-id="cc7db-102">[x] Proposed</span></span>
* <span data-ttu-id="cc7db-103">[x] 原型：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span><span class="sxs-lookup"><span data-stu-id="cc7db-103">[x] Prototype: [Complete](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span></span>
* <span data-ttu-id="cc7db-104">[x] 实现：[完成](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span><span class="sxs-lookup"><span data-stu-id="cc7db-104">[x] Implementation: [Complete](https://github.com/dotnet/roslyn/blob/master/docs/features/private-protected.md)</span></span>
* <span data-ttu-id="cc7db-105">[x] 规范：[完成](#detailed-design)</span><span class="sxs-lookup"><span data-stu-id="cc7db-105">[x] Specification: [Complete](#detailed-design)</span></span>

## <a name="summary"></a><span data-ttu-id="cc7db-106">总结</span><span class="sxs-lookup"><span data-stu-id="cc7db-106">Summary</span></span>
[summary]: #summary

<span data-ttu-id="cc7db-107">以 `private protected`的C#形式公开 CLR `protectedAndInternal` 的可访问性级别。</span><span class="sxs-lookup"><span data-stu-id="cc7db-107">Expose the CLR `protectedAndInternal` accessibility level in C# as `private protected`.</span></span>

## <a name="motivation"></a><span data-ttu-id="cc7db-108">动机</span><span class="sxs-lookup"><span data-stu-id="cc7db-108">Motivation</span></span>
[motivation]: #motivation

<span data-ttu-id="cc7db-109">在许多情况下，API 包含的成员只应由提供该类型的程序集中包含的子类实现和使用。</span><span class="sxs-lookup"><span data-stu-id="cc7db-109">There are many circumstances in which an API contains members that are only intended to be implemented and used by subclasses contained in the assembly that provides the type.</span></span> <span data-ttu-id="cc7db-110">虽然 CLR 为此目的提供了一个可访问性级别，但它在C#中不可用。</span><span class="sxs-lookup"><span data-stu-id="cc7db-110">While the CLR provides an accessibility level for that purpose, it is not available in C#.</span></span> <span data-ttu-id="cc7db-111">因此，API 所有者被迫使用 `internal` 保护和自助式或自定义分析器，或将 `protected` 与其他文档一起使用，以说明该成员出现在该类型的公共文档中，而不是作为公共 API 的一部分。</span><span class="sxs-lookup"><span data-stu-id="cc7db-111">Consequently API owners are forced to either use `internal` protection and self-discipline or a custom analyzer, or to use `protected` with additional documentation explaining that, while the member appears in the public documentation for the type, it is not intended to be part of the public API.</span></span>  <span data-ttu-id="cc7db-112">有关后者的示例，请参阅名称以 `Common`开头的 Roslyn `CSharpCompilationOptions` 的成员。</span><span class="sxs-lookup"><span data-stu-id="cc7db-112">For examples of the latter, see members of Roslyn's `CSharpCompilationOptions` whose names start with `Common`.</span></span>

<span data-ttu-id="cc7db-113">在中C#直接提供对此访问级别的支持可使这些情况以语言自然表达。</span><span class="sxs-lookup"><span data-stu-id="cc7db-113">Directly providing support for this access level in C# enables these circumstances to be expressed naturally in the language.</span></span>

## <a name="detailed-design"></a><span data-ttu-id="cc7db-114">详细设计</span><span class="sxs-lookup"><span data-stu-id="cc7db-114">Detailed design</span></span>
[design]: #detailed-design

### <a name="private-protected-access-modifier"></a><span data-ttu-id="cc7db-115">`private protected` 访问修饰符</span><span class="sxs-lookup"><span data-stu-id="cc7db-115">`private protected` access modifier</span></span>

<span data-ttu-id="cc7db-116">建议添加新的访问修饰符组合 `private protected` （可在修饰符中以任意顺序出现）。</span><span class="sxs-lookup"><span data-stu-id="cc7db-116">We propose to add a new access modifier combination `private protected` (which can appear in any order among the modifiers).</span></span> <span data-ttu-id="cc7db-117">这会映射到 protectedAndInternal 的 CLR 概念，并借用当前在[ C++/cli](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility)中使用的语法。</span><span class="sxs-lookup"><span data-stu-id="cc7db-117">This maps to the CLR notion of protectedAndInternal, and borrows the same syntax currently used in [C++/CLI](https://docs.microsoft.com/cpp/dotnet/how-to-define-and-consume-classes-and-structs-cpp-cli#BKMK_Member_visibility).</span></span>

<span data-ttu-id="cc7db-118">如果 `private protected` 声明的成员，则可以在其容器的子类中访问该成员，前提是该子类与成员在同一程序集中。</span><span class="sxs-lookup"><span data-stu-id="cc7db-118">A member declared `private protected` can be accessed within a subclass of its container if that subclass is in the same assembly as the member.</span></span>

<span data-ttu-id="cc7db-119">修改语言规范，如下所示（以粗体添加）。</span><span class="sxs-lookup"><span data-stu-id="cc7db-119">We modify the language specification as follows (additions in bold).</span></span> <span data-ttu-id="cc7db-120">节号不如下所示，具体取决于它所集成到的规范版本。</span><span class="sxs-lookup"><span data-stu-id="cc7db-120">Section numbers are not shown below as they may vary depending on which version of the specification it is integrated into.</span></span>

-----

> <span data-ttu-id="cc7db-121">成员的声明可访问性可以是以下项之一：</span><span class="sxs-lookup"><span data-stu-id="cc7db-121">The declared accessibility of a member can be one of the following:</span></span>
- <span data-ttu-id="cc7db-122">Public，通过在成员声明中包含一个公共修饰符来选择。</span><span class="sxs-lookup"><span data-stu-id="cc7db-122">Public, which is selected by including a public modifier in the member declaration.</span></span> <span data-ttu-id="cc7db-123">Public 的直观含义是 "访问不受限制"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-123">The intuitive meaning of public is “access not limited”.</span></span>
- <span data-ttu-id="cc7db-124">Protected：通过在成员声明中包括受保护的修饰符来选择。</span><span class="sxs-lookup"><span data-stu-id="cc7db-124">Protected, which is selected by including a protected modifier in the member declaration.</span></span> <span data-ttu-id="cc7db-125">受保护的直观含义为 "访问限制为包含类或派生自包含类的类型"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-125">The intuitive meaning of protected is “access limited to the containing class or types derived from the containing class”.</span></span>
- <span data-ttu-id="cc7db-126">内部，通过在成员声明中包含内部修饰符来选择。</span><span class="sxs-lookup"><span data-stu-id="cc7db-126">Internal, which is selected by including an internal modifier in the member declaration.</span></span> <span data-ttu-id="cc7db-127">内部的直观含义为 "访问限制为此程序集"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-127">The intuitive meaning of internal is “access limited to this assembly”.</span></span>
- <span data-ttu-id="cc7db-128">受保护的内部，通过将受保护的和内部修饰符同时包含在成员声明中来选择。</span><span class="sxs-lookup"><span data-stu-id="cc7db-128">Protected internal, which is selected by including both a protected and an internal modifier in the member declaration.</span></span> <span data-ttu-id="cc7db-129">受保护的内部的直观含义是 "在此程序集内可访问，以及派生自包含类的类型"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-129">The intuitive meaning of protected internal is “accessible within this assembly as well as types derived from the containing class”.</span></span>
- <span data-ttu-id="cc7db-130">**私有受保护的，它通过在成员声明中同时包含 private 修饰符和 protected 修饰符来选择。"私有" 受保护的直观含义是 "在此程序集中按派生自包含类的类型进行访问"。**</span><span class="sxs-lookup"><span data-stu-id="cc7db-130">**Private protected, which is selected by including both a private and a protected modifier in the member declaration. The intuitive meaning of private protected is “accessible within this assembly by types derived from the containing class”.**</span></span>

-----

> <span data-ttu-id="cc7db-131">根据成员声明发生的上下文，仅允许某些类型的声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-131">Depending on the context in which a member declaration takes place, only certain types of declared accessibility are permitted.</span></span> <span data-ttu-id="cc7db-132">此外，当成员声明中不包含任何访问修饰符时，在其中进行声明的上下文会确定默认的声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-132">Furthermore, when a member declaration does not include any access modifiers, the context in which the declaration takes place determines the default declared accessibility.</span></span> 
- <span data-ttu-id="cc7db-133">命名空间隐式具有公开声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-133">Namespaces implicitly have public declared accessibility.</span></span> <span data-ttu-id="cc7db-134">命名空间声明中不允许使用访问修饰符。</span><span class="sxs-lookup"><span data-stu-id="cc7db-134">No access modifiers are allowed on namespace declarations.</span></span>
- <span data-ttu-id="cc7db-135">直接在编译单元或命名空间中声明的类型（而不是在其他类型中）可具有公共或内部声明的可访问性，并且默认为内部声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-135">Types declared directly in compilation units or namespaces (as opposed to within other types) can have public or internal declared accessibility and default to internal declared accessibility.</span></span>
- <span data-ttu-id="cc7db-136">类成员可以具有五种声明的可访问性，并且默认为私有声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-136">Class members can have any of the five kinds of declared accessibility and default to private declared accessibility.</span></span> <span data-ttu-id="cc7db-137">[注意：声明为类成员的类型可以具有五种声明可访问性中的任何一种，而声明为命名空间成员的类型只能具有公共或内部声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-137">[Note: A type declared as a member of a class can have any of the five kinds of declared accessibility, whereas a type declared as a member of a namespace can have only public or internal declared accessibility.</span></span> <span data-ttu-id="cc7db-138">结束说明]</span><span class="sxs-lookup"><span data-stu-id="cc7db-138">end note]</span></span>
- <span data-ttu-id="cc7db-139">结构成员可具有公共、内部或私有声明的可访问性，并且默认为私有声明的可访问性，因为结构是隐式密封的。</span><span class="sxs-lookup"><span data-stu-id="cc7db-139">Struct members can have public, internal, or private declared accessibility and default to private declared accessibility because structs are implicitly sealed.</span></span> <span data-ttu-id="cc7db-140">结构中引入的结构成员（即，不是由该结构继承）无法具有受保护*的、* ~~受保护~~的内部或受保护的**私有**可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-140">Struct members introduced in a struct (that is, not inherited by that struct) cannot have protected *,* ~~or~~ protected internal **, or private protected** declared accessibility.</span></span> <span data-ttu-id="cc7db-141">[注意：声明为结构成员的类型可以具有公共、内部或私有声明的可访问性，而声明为命名空间成员的类型只能具有公共或内部声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-141">[Note: A type declared as a member of a struct can have public, internal, or private declared accessibility, whereas a type declared as a member of a namespace can have only public or internal declared accessibility.</span></span> <span data-ttu-id="cc7db-142">结束说明]</span><span class="sxs-lookup"><span data-stu-id="cc7db-142">end note]</span></span>
- <span data-ttu-id="cc7db-143">接口成员隐式具有公开声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-143">Interface members implicitly have public declared accessibility.</span></span> <span data-ttu-id="cc7db-144">接口成员声明中不允许使用访问修饰符。</span><span class="sxs-lookup"><span data-stu-id="cc7db-144">No access modifiers are allowed on interface member declarations.</span></span>
- <span data-ttu-id="cc7db-145">枚举成员隐式具有公开声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-145">Enumeration members implicitly have public declared accessibility.</span></span> <span data-ttu-id="cc7db-146">枚举成员声明中不允许使用访问修饰符。</span><span class="sxs-lookup"><span data-stu-id="cc7db-146">No access modifiers are allowed on enumeration member declarations.</span></span>

-----

> <span data-ttu-id="cc7db-147">在程序 P 中，在类型 T 中声明的嵌套成员 M 的可访问域定义如下（注意： M 本身可能是一个类型）：</span><span class="sxs-lookup"><span data-stu-id="cc7db-147">The accessibility domain of a nested member M declared in a type T within a program P, is defined as follows (noting that M itself might possibly be a type):</span></span>
- <span data-ttu-id="cc7db-148">如果 M 的声明的可访问性是公共的，则 M 的可访问域是 T 的可访问域。</span><span class="sxs-lookup"><span data-stu-id="cc7db-148">If the declared accessibility of M is public, the accessibility domain of M is the accessibility domain of T.</span></span>
- <span data-ttu-id="cc7db-149">如果 M 的声明的可访问性是受保护的，则让 D 成为 P 的程序文本和从 T 派生的任何类型的程序文本的并集。M 的可访问域是 T 的可访问域与 D 的交集。</span><span class="sxs-lookup"><span data-stu-id="cc7db-149">If the declared accessibility of M is protected internal, let D be the union of the program text of P and the program text of any type derived from T, which is declared outside P. The accessibility domain of M is the intersection of the accessibility domain of T with D.</span></span>
- <span data-ttu-id="cc7db-150">**如果 "M" 的声明的可访问性受私有保护，则将 D 作为程序文本 P 和从 T 派生的任何类型的程序文本的交集。M 的可访问域是 T 的可访问域与 D 的交集。**</span><span class="sxs-lookup"><span data-stu-id="cc7db-150">**If the declared accessibility of M is private protected, let D be the intersection of the program text of P and the program text of any type derived from T. The accessibility domain of M is the intersection of the accessibility domain of T with D.**</span></span>
- <span data-ttu-id="cc7db-151">如果 "M" 的声明的可访问性受到保护，则将 D 的程序文本和从 T 派生的任何类型的程序文本合并。M 的可访问域是 T 的可访问域与 D 的交集。</span><span class="sxs-lookup"><span data-stu-id="cc7db-151">If the declared accessibility of M is protected, let D be the union of the program text of T and the program text of any type derived from T. The accessibility domain of M is the intersection of the accessibility domain of T with D.</span></span>
- <span data-ttu-id="cc7db-152">如果 M 的声明可访问性为 internal，则 M 的可访问域是 T 的可访问域与 P 的程序文本的交集。</span><span class="sxs-lookup"><span data-stu-id="cc7db-152">If the declared accessibility of M is internal, the accessibility domain of M is the intersection of the accessibility domain of T with the program text of P.</span></span>
- <span data-ttu-id="cc7db-153">如果 M 的声明的可访问性是私有的，则 M 的可访问域是 T 的程序文本。</span><span class="sxs-lookup"><span data-stu-id="cc7db-153">If the declared accessibility of M is private, the accessibility domain of M is the program text of T.</span></span>

-----

> <span data-ttu-id="cc7db-154">当受保护**或**受保护的私有实例成员在声明它的类的程序文本之外访问时，以及当受保护的内部实例成员在声明它的程序的程序文本的外部访问时，应在从其声明的类派生的类声明中进行访问。</span><span class="sxs-lookup"><span data-stu-id="cc7db-154">When a protected **or private protected** instance member is accessed outside the program text of the class in which it is declared, and when a protected internal instance member is accessed outside the program text of the program in which it is declared, the access shall take place within a class declaration that derives from the class in which it is declared.</span></span> <span data-ttu-id="cc7db-155">此外，需要通过派生类类型的实例或从其构造的类类型进行访问。</span><span class="sxs-lookup"><span data-stu-id="cc7db-155">Furthermore, the access is required to take place through an instance of that derived class type or a class type constructed from it.</span></span> <span data-ttu-id="cc7db-156">此限制可防止一个派生类访问其他派生类的受保护成员，即使这些成员是从同一个基类继承时也是如此。</span><span class="sxs-lookup"><span data-stu-id="cc7db-156">This restriction prevents one derived class from accessing protected members of other derived classes, even when the members are inherited from the same base class.</span></span>

-----

> <span data-ttu-id="cc7db-157">允许的访问修饰符和类型声明的默认访问权限取决于声明发生的上下文（第9.5.2）：</span><span class="sxs-lookup"><span data-stu-id="cc7db-157">The permitted access modifiers and the default access for a type declaration depend on the context in which the declaration takes place (§9.5.2):</span></span>
- <span data-ttu-id="cc7db-158">在编译单元或命名空间中声明的类型可以具有公共或内部访问权限。</span><span class="sxs-lookup"><span data-stu-id="cc7db-158">Types declared in compilation units or namespaces can have public or internal access.</span></span> <span data-ttu-id="cc7db-159">默认值为 "内部访问"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-159">The default is internal access.</span></span>
- <span data-ttu-id="cc7db-160">类中声明的类型可以具有公共、受保护的内部、受保护的**内部、受**保护、内部或私有访问权限。</span><span class="sxs-lookup"><span data-stu-id="cc7db-160">Types declared in classes can have public, protected internal, **private protected**, protected, internal, or private access.</span></span> <span data-ttu-id="cc7db-161">默认值为 "专用访问"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-161">The default is private access.</span></span>
- <span data-ttu-id="cc7db-162">结构中声明的类型可以具有公共、内部或私有访问权限。</span><span class="sxs-lookup"><span data-stu-id="cc7db-162">Types declared in structs can have public, internal, or private access.</span></span> <span data-ttu-id="cc7db-163">默认值为 "专用访问"。</span><span class="sxs-lookup"><span data-stu-id="cc7db-163">The default is private access.</span></span>

-----

> <span data-ttu-id="cc7db-164">静态类声明受到下列限制：</span><span class="sxs-lookup"><span data-stu-id="cc7db-164">A static class declaration is subject to the following restrictions:</span></span>
- <span data-ttu-id="cc7db-165">静态类不应包含 sealed 修饰符或 abstract 修饰符。</span><span class="sxs-lookup"><span data-stu-id="cc7db-165">A static class shall not include a sealed or abstract modifier.</span></span> <span data-ttu-id="cc7db-166">（但是，由于无法对静态类进行实例化或派生，因此它的行为就像它既是密封的又是抽象的。）</span><span class="sxs-lookup"><span data-stu-id="cc7db-166">(However, since a static class cannot be instantiated or derived from, it behaves as if it was both sealed and abstract.)</span></span>
- <span data-ttu-id="cc7db-167">静态类不应包括类基规范（第16.2.5），并且不能显式指定基类或已实现接口的列表。</span><span class="sxs-lookup"><span data-stu-id="cc7db-167">A static class shall not include a class-base specification (§16.2.5) and cannot explicitly specify a base class or a list of implemented interfaces.</span></span> <span data-ttu-id="cc7db-168">静态类隐式继承自类型对象。</span><span class="sxs-lookup"><span data-stu-id="cc7db-168">A static class implicitly inherits from type object.</span></span>
- <span data-ttu-id="cc7db-169">静态类只应包含静态成员（第16.4.8）。</span><span class="sxs-lookup"><span data-stu-id="cc7db-169">A static class shall only contain static members (§16.4.8).</span></span> <span data-ttu-id="cc7db-170">[注意：所有常量和嵌套类型都分类为静态成员。</span><span class="sxs-lookup"><span data-stu-id="cc7db-170">[Note: All constants and nested types are classified as static members.</span></span> <span data-ttu-id="cc7db-171">结束说明]</span><span class="sxs-lookup"><span data-stu-id="cc7db-171">end note]</span></span>
- <span data-ttu-id="cc7db-172">静态类不应具有受保护 **、私有保护**或受保护的内部声明可访问性的成员。</span><span class="sxs-lookup"><span data-stu-id="cc7db-172">A static class shall not have members with protected **, private protected** or protected internal declared accessibility.</span></span>

> <span data-ttu-id="cc7db-173">这是一种编译时错误，违反其中的任何限制。</span><span class="sxs-lookup"><span data-stu-id="cc7db-173">It is a compile-time error to violate any of these restrictions.</span></span> 

-----

> <span data-ttu-id="cc7db-174">类成员声明可以具有~~五~~**种可能类型**的声明的可访问性（第9.5.2）中的任意一种：公共、**私有受保护**、受保护的内部、受保护、内部或私有。</span><span class="sxs-lookup"><span data-stu-id="cc7db-174">A class-member-declaration can have any one of the ~~five~~**six** possible kinds of declared accessibility (§9.5.2): public, **private protected**, protected internal, protected, internal, or private.</span></span> <span data-ttu-id="cc7db-175">除了受保护的内部**和私有保护**组合**以外**，还可以指定多个访问修饰符，这是编译时错误。</span><span class="sxs-lookup"><span data-stu-id="cc7db-175">Except for the protected internal **and private protected** combination**s**, it is a compile-time error to specify more than one access modifier.</span></span> <span data-ttu-id="cc7db-176">当类成员声明不包括任何访问修饰符时，将假定 private。</span><span class="sxs-lookup"><span data-stu-id="cc7db-176">When a class-member-declaration does not include any access modifiers, private is assumed.</span></span>

-----

> <span data-ttu-id="cc7db-177">非嵌套类型可以具有公共或内部声明的可访问性，并且默认情况下具有内部声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-177">Non-nested types can have public or internal declared accessibility and have internal declared accessibility by default.</span></span> <span data-ttu-id="cc7db-178">嵌套类型也可以具有这些形式的声明的可访问性，还可以包含一个或多个声明的可访问性的其他形式，具体取决于包含类型是否为类或结构：</span><span class="sxs-lookup"><span data-stu-id="cc7db-178">Nested types can have these forms of declared accessibility too, plus one or more additional forms of declared accessibility, depending on whether the containing type is a class or struct:</span></span>
- <span data-ttu-id="cc7db-179">在类中声明的嵌套类型可以具有~~五~~**种**声明的可访问性（公共、**私有受保护**、受保护的内部、受保护、内部或私有）形式的任何形式，与其他类成员一样，默认情况下为私有声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-179">A nested type that is declared in a class can have any of ~~five~~**six** forms of declared accessibility (public, **private protected**, protected internal, protected, internal, or private) and, like other class members, defaults to private declared accessibility.</span></span>
- <span data-ttu-id="cc7db-180">在结构中声明的嵌套类型可以有三种形式的声明的可访问性（public、internal 或 private），与其他结构成员一样，默认为私有声明的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-180">A nested type that is declared in a struct can have any of three forms of declared accessibility (public, internal, or private) and, like other struct members, defaults to private declared accessibility.</span></span>

-----

> <span data-ttu-id="cc7db-181">重写声明重写的方法被称为替代方法的重写基方法。在 c 类中声明的方法是，通过检查 C 的每个基类类型（从 C 的直接基类类型开始）来确定重写的基方法继续使用每个连续的直接基类类型，直到在给定基类类型中，至少有一个可访问方法与类型参数替换后的 M 具有相同的签名。</span><span class="sxs-lookup"><span data-stu-id="cc7db-181">The method overridden by an override declaration is known as the overridden base method For an override method M declared in a class C, the overridden base method is determined by examining each base class type of C, starting with the direct base class type of C and continuing with each successive direct base class type, until in a given base class type at least one accessible method is located which has the same signature as M after substitution of type arguments.</span></span> <span data-ttu-id="cc7db-182">为了定位重写的基方法，如果方法是公共的（如果它是受保护的），或者**它是受**保护的（如果是受保护的），或者它是在 C 的同一程序中进行内部**或私有保护**并声明的，则该方法将被视为可访问。</span><span class="sxs-lookup"><span data-stu-id="cc7db-182">For the purposes of locating the overridden base method, a method is considered accessible if it is public, if it is protected, if it is protected internal, or if it is **either** internal **or private protected** and declared in the same program as C.</span></span>

-----

> <span data-ttu-id="cc7db-183">访问器修饰符的使用受以下限制的约束：</span><span class="sxs-lookup"><span data-stu-id="cc7db-183">The use of accessor-modifiers is governed by the following restrictions:</span></span>
- <span data-ttu-id="cc7db-184">访问器修饰符不能在接口或显式接口成员实现中使用。</span><span class="sxs-lookup"><span data-stu-id="cc7db-184">An accessor-modifier shall not be used in an interface or in an explicit interface member implementation.</span></span>
- <span data-ttu-id="cc7db-185">对于没有 override 修饰符的属性或索引器，仅当属性或索引器同时具有 get 访问器和 set 访问器时才允许使用访问器修饰符，只允许在其中一种访问器上使用。</span><span class="sxs-lookup"><span data-stu-id="cc7db-185">For a property or indexer that has no override modifier, an accessor-modifier is permitted only if the property or indexer has both a get and set accessor, and then is permitted only on one of those accessors.</span></span>
- <span data-ttu-id="cc7db-186">对于包含 override 修饰符的属性或索引器，取值函数应与要重写的访问器的访问器修饰符（如果有）匹配。</span><span class="sxs-lookup"><span data-stu-id="cc7db-186">For a property or indexer that includes an override modifier, an accessor shall match the accessor-modifier, if any, of the accessor being overridden.</span></span>
- <span data-ttu-id="cc7db-187">访问器修饰符应声明比属性或索引器本身的声明的可访问性严格更严格的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-187">The accessor-modifier shall declare an accessibility that is strictly more restrictive than the declared accessibility of the property or indexer itself.</span></span> <span data-ttu-id="cc7db-188">精确：</span><span class="sxs-lookup"><span data-stu-id="cc7db-188">To be precise:</span></span>
  - <span data-ttu-id="cc7db-189">如果属性或索引器具有 "公共" 的声明的可访问性，则访问器修饰符可以是**私有保护**的、受保护的内部、受保护的或私有的。</span><span class="sxs-lookup"><span data-stu-id="cc7db-189">If the property or indexer has a declared accessibility of public, the accessor-modifier may be either **private protected**, , protected internal, internal, protected, or private.</span></span>
  - <span data-ttu-id="cc7db-190">如果属性或索引器具有已声明的受保护的可访问性，则访问器修饰符可以是**私有保护**的、内部、受保护的或私有的。</span><span class="sxs-lookup"><span data-stu-id="cc7db-190">If the property or indexer has a declared accessibility of protected internal, the accessor-modifier may be either **private protected**, internal, protected, or private.</span></span>
  - <span data-ttu-id="cc7db-191">如果属性或索引器具有内部或受保护的声明的可访问性，则访问器修饰符应为**私有保护或**私有。</span><span class="sxs-lookup"><span data-stu-id="cc7db-191">If the property or indexer has a declared accessibility of internal or protected, the accessor-modifier shall be **either private protected or** private.</span></span>
  - <span data-ttu-id="cc7db-192">**如果属性或索引器具有已声明的私有受保护的可访问性，则访问器修饰符应为私有。**</span><span class="sxs-lookup"><span data-stu-id="cc7db-192">**If the property or indexer has a declared accessibility of private protected, the accessor-modifier shall be private.**</span></span>
  - <span data-ttu-id="cc7db-193">如果属性或索引器具有声明的私有可访问性，则不能使用访问器修饰符。</span><span class="sxs-lookup"><span data-stu-id="cc7db-193">If the property or indexer has a declared accessibility of private, no accessor-modifier may be used.</span></span>

-----

> <span data-ttu-id="cc7db-194">由于结构不支持继承，因此无法保护、**私有受保护**或受保护的内部结构成员的可访问性。</span><span class="sxs-lookup"><span data-stu-id="cc7db-194">Since inheritance isn’t supported for structs, the declared accessibility of a struct member cannot be protected, **private protected**, or protected internal.</span></span>

-----

## <a name="drawbacks"></a><span data-ttu-id="cc7db-195">缺点</span><span class="sxs-lookup"><span data-stu-id="cc7db-195">Drawbacks</span></span>
[drawbacks]: #drawbacks

<span data-ttu-id="cc7db-196">与任何语言功能一样，我们必须回答对语言的额外复杂性是否偿还，以提供给将从功能中受益的C#程序的主体。</span><span class="sxs-lookup"><span data-stu-id="cc7db-196">As with any language feature, we must question whether the additional complexity to the language is repaid in the additional clarity offered to the body of C# programs that would benefit from the feature.</span></span>

## <a name="alternatives"></a><span data-ttu-id="cc7db-197">备选项</span><span class="sxs-lookup"><span data-stu-id="cc7db-197">Alternatives</span></span>
[alternatives]: #alternatives

<span data-ttu-id="cc7db-198">替代方法是将属性与分析器组合在一起。</span><span class="sxs-lookup"><span data-stu-id="cc7db-198">An alternative would be the provision of an API combining an attribute and an analyzer.</span></span> <span data-ttu-id="cc7db-199">特性由程序员放置在一个 `internal` 成员上，以指示该成员仅用于子类中，而分析器会检查这些限制是否已服从。</span><span class="sxs-lookup"><span data-stu-id="cc7db-199">The attribute is placed by the programmer on an `internal` member to indicates that the member is intended to be used only in subclasses, and the analyzer checks that those restrictions are obeyed.</span></span> 

## <a name="unresolved-questions"></a><span data-ttu-id="cc7db-200">未解决的问题</span><span class="sxs-lookup"><span data-stu-id="cc7db-200">Unresolved questions</span></span>
[unresolved]: #unresolved-questions

<span data-ttu-id="cc7db-201">实现大致完成。</span><span class="sxs-lookup"><span data-stu-id="cc7db-201">The implementation is largely complete.</span></span> <span data-ttu-id="cc7db-202">唯一打开的工作项将为 VB 起草相应规范。</span><span class="sxs-lookup"><span data-stu-id="cc7db-202">The only open work item is drafting a corresponding specification for VB.</span></span>

## <a name="design-meetings"></a><span data-ttu-id="cc7db-203">设计会议</span><span class="sxs-lookup"><span data-stu-id="cc7db-203">Design meetings</span></span>

<span data-ttu-id="cc7db-204">TBD</span><span class="sxs-lookup"><span data-stu-id="cc7db-204">TBD</span></span>
