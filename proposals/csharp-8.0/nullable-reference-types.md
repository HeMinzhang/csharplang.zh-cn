---
ms.openlocfilehash: ecdad8c863d0695bc901e4d96d9ca3decbc248eb
ms.sourcegitcommit: 94a3d151c438d34ede1d99de9eb4ebdc07ba4699
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/25/2019
ms.locfileid: "79483594"
---
# <a name="nullable-reference-types-in-c"></a>中的可以为 null 的引用类型C# #

此功能的目标是：

* 允许开发人员表达引用类型的变量、参数或结果是否应为空。
* 当不根据此目的使用此类变量、参数和结果时提供警告。

## <a name="expression-of-intent"></a>意向表达式

该语言已包含值类型的 `T?` 语法。 向引用类型扩展此语法非常简单。

假设未修饰引用类型 `T` 的目的是将其视为非 null。

## <a name="checking-of-nullable-references"></a>检查可以为 null 的引用

流分析跟踪可以为 null 的引用变量。 如果分析认为它们不会为 null （例如，在检查或分配之后），则将其值视为非空引用。

如果流分析无法建立开发人员知道的非空情况，则可以使用后缀 `x!` 运算符（"dammit" 运算符）将可为 null 的引用显式视为非 null。

否则，如果取消引用可为 null 的引用或者将其转换为非 null 类型，则会发出警告。

从 `S[]` 转换到 `T?[]` 以及从 `S?[]` 转换到 `T[]`时，将发出警告。

从 `C<S>` 转换到 `C<T?>` 时，除了类型参数是协变的（`out`）以及在从 `C<S?>` 转换为 `C<T>` 时（在类型参数为逆变（`in`）时除外），会发出警告。

如果类型参数具有非 null 约束，则 `C<T?>` 上提供警告。 

## <a name="checking-of-non-null-references"></a>检查非空引用

如果将 null 文本分配给非 null 变量或作为非 null 参数传递，则会发出警告。

如果构造函数未显式初始化非空引用字段，则还会发出警告。

我们无法充分跟踪非空引用数组的所有元素是否已初始化。 但是，如果在从或传入数组之前没有将新创建的数组的元素分配给，我们可能会发出警告。 这可能会处理常见情况，而不会干扰。

我们需要决定 `default(T)` 生成警告，还是只将其视为 `T?`类型。

## <a name="metadata-representation"></a>元数据表示形式

应为空性修饰在元数据中表示为属性。 这意味着下层编译器将忽略它们。

我们需要确定是否只包含可为 null 的批注，或者程序集中是否存在非 null 的指示。

## <a name="generics"></a>泛型

如果某个类型参数 `T` 具有不可为 null 的约束，则该类型参数在其作用域内被视为不可为 null。

如果类型参数不受约束或只有可为 null 的约束，则这种情况稍微复杂一些：这意味着相应的类型参数可以*为 null，也可以是*不可为 null 的。 在这种情况下要执行的安全操作是将类型*参数视为可以为 null 和*不可为 null，并在违反时发出警告。 

需要考虑是否应允许显式可为 null 的引用约束。 但请注意，在某些情况下，我们无法避免将可为 null 的引用类型*隐式*作为约束（继承的约束）。

`class` 约束为非 null。 我们可以考虑 `class?` 是否应该是表示 "可以为 null 的引用类型" 的有效可为 null 的约束。

## <a name="type-inference"></a>类型推理

在类型推理中，如果参与类型是可以为 null 的引用类型，则结果类型应为 null。 换句话说，非 null 是传播的。

应考虑 `null` 文本是否为参与表达式应非 null。 目前不是：对于值类型，它会导致错误，而对于引用类型，null 成功转换为纯类型。 

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="breaking-changes"></a>重大更改

非 null 警告是对现有代码的明显重大更改，并应附带有选择的机制。

不太明显，可以为 null 的类型的警告（如上所述）在可为 null 性为隐式的某些情况下，对现有代码进行重大更改：

* 不受约束的类型参数将被视为隐式的，因此将其分配给 `object` 或访问，例如 `ToString` 将产生警告。
* 如果类型推理从 `null` 表达式推断出非 null，则现有代码有时会产生可为 null 的类型，而不是不可为 null 的类型，这可能会导致新的警告。

因此，可以为 null 的警告也需要是可选的

最后，将批注添加到现有 API 将是在升级库时选择了警告的用户的重大更改。 这也可以选择加入或退出。"我想修复 bug，但未准备好处理其新注释"

总之，你需要能够选择加入/退出：
* 可以为 null 的警告
* 非 null 警告
* 其他文件中的批注警告

选择的粒度建议使用类似于分析器的模型，在该模型中，大量的代码可以选择使用杂注，而用户可以选择严重级别。 此外，每个库选项（"从 JSON.NET 中忽略批注，直到我准备好处理"）可以在代码中作为属性来表达。

选择加入/过渡体验的设计对于此功能的成功和有用性至关重要。 我们需要确保：

* 用户可以根据需要逐步采用空性检查
* 库作者可以添加可为 null 性的注释，而无需担心用户中断
* 尽管如此，这并不是 "配置不足"

## <a name="tweaks"></a>调整

我们可以考虑不在局部变量上使用 `?` 注释，而只是根据分配给它们的内容来观察是否使用它们。 我不愿意这样做;我想我们应该统一让人们表达自己的意图。

对于参数，可以考虑使用简写 `T! x` 来自动生成运行时 null 检查。

某些泛型类型上的特定模式（如 `FirstOrDefault` 或 `TryGet`）具有不可以为 null 的类型参数的轻微行为，因为在某些情况下它们会显式生成默认值。 我们可以尝试对类型系统进行细微差别，以使其更好地适应。 例如，我们可以允许对不受约束的类型参数进行 `?`，即使类型参数可以是可以为 null 的。 我怀疑这是值得的，这会导致与可为 null 的*值*类型的交互相关的问题。 

## <a name="nullable-value-types"></a>可以为 null 的值类型

对于可以为 null 的值类型，我们可以考虑采用上述语义。

我们已提到类型推理，可在其中推断 `(7, null)``int?`，而不是仅仅提供错误。

另一种机会是将流分析应用于可为 null 的值类型。 如果被视为非 null，我们实际上可以允许在某些方面（例如，成员访问）使用作为不可为 null 的类型。 我们只需小心，你可以在可以为 null 的值类型*上执行的操作就*是出于后向兼容的原因。
