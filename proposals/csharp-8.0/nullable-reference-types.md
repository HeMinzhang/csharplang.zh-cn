---
ms.openlocfilehash: 54f9a372ca0329a284f06876f544e0b4936af02a
ms.sourcegitcommit: 356ee04506a2a82292be25d7b029e7ce2a39e63a
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/22/2020
ms.locfileid: "82037397"
---
# <a name="nullable-reference-types-in-c"></a>C 中的空引用类型# #

此功能的目标是：

* 允许开发人员表示引用类型的变量、参数或结果是否为空。
* 当此类变量、参数和结果未按照该意图使用时，提供警告。

## <a name="expression-of-intent"></a>意向表达

语言已包含值类型的`T?`语法。 将此语法扩展到引用类型非常简单。

假定未修饰引用类型`T`的意图是将其为非 null。

## <a name="checking-of-nullable-references"></a>检查可取消的引用

流分析跟踪可无值引用变量。 如果分析认为它们不为空（例如，在检查或分配之后），其值将被视为非空引用。

对于流分析无法建立开发人员知道存在的非空情况时，可以使用后修复`x!`运算符（"damnit"运算符）显式将空引用视为非空引用。

否则，如果取消引用的空引用或转换为非空类型，则发出警告。

从`S[]`转换到`T?[]`和`S?[]`时，将发出警告。 `T[]`

`C<S>`当从`C<T?>`转换 到 ，当类型参数为协变量 （）`out`时，以及从`C<S?>`转换`C<T>`到 ，当类型参数是反变量`in`（） 时，将发出警告。

`C<T?>`如果类型参数具有非 null 约束，则发出警告。

## <a name="checking-of-non-null-references"></a>检查非空引用

如果将空文本分配给非空变量或作为非空参数传递，则发出警告。

如果构造函数未显式初始化非空引用字段，也会发出警告。

我们无法充分跟踪非空引用数组的所有元素是否初始化。 但是，如果在读取或传递数组之前未分配新创建的数组的元素，我们可以发出警告。 这可能处理常见的情况，而不会太吵。

我们需要决定是`default(T)`生成警告，还是简单地被视为类型`T?`。

## <a name="metadata-representation"></a>元数据表示

可空装饰应在元数据中表示为属性。 这意味着低级编译器将忽略它们。

我们需要决定是否只包括空注释，或者在程序集中是否"打开"也显示非 null。

## <a name="generics"></a>泛型

如果类型参数`T`具有不可取消的约束，则在其范围内将其视为不可消除。

如果类型参数不受限制或仅具有可无约束约束，则情况会稍微复杂一些：这意味着相应的类型*参数可以是*null 的，也可以是非 null 的。 在这种情况下，安全的做法是将类型*参数视为可*取消和不可取消，当违反任一时发出警告。 

值得考虑的是，是否应允许显式空引用约束。 但是请注意，在某些情况下，我们无法避免将可隐含的引用类型*隐式*为约束（继承约束）。

约束`class`为非空。 我们可以考虑是否应`class?`是表示"空引用类型"的有效空约束。

## <a name="type-inference"></a>类型推理

在类型推理中，如果贡献类型是空引用类型，则生成的类型应为空。 换句话说，nullin 是传播的。

我们应该考虑作为参与表达式`null`的字面是否应导致无效。 它今天不是：对于值类型，它会导致错误，而对于引用类型，null 成功转换为普通类型。

```csharp
string? n = "world";
var x = b ? "Hello" : n; // string?
var y = b ? "Hello" : null; // string? or error
var z = b ? 7 : null; // Error today, could be int?
```

## <a name="null-guard-guidance"></a>空防护制导

作为一项功能，可无效的引用类型允许开发人员表达其意图，并在该意图与该意图相矛盾时通过流分析发出警告。 对于是否有必要进行零空防护，存在一个常见的问题。

### <a name="example-of-null-guard"></a>空防护示例

```csharp
public void DoWork(Worker worker)
{
    // Guard against worker being null
    if (worker is null)
    {
        throw new ArgumentNullException(nameof(worker));
    }

    // Otherwise use worker argument
}
```

在前面的示例中，函数`DoWork`接受 和`Worker`，防止它可能是 。 `null` 如果`worker`参数为`null`，则`DoWork`函数将`throw`。 对于可 null 引用类型，上一示例中的代码使`Worker`参数的用意*不是*`null`。 如果`DoWork`函数是公共 API（如 NuGet 包或共享库），则作为指南，应保留空防护装置。 作为公共 API，呼叫者不传递`null`的唯一保证是防止它。

### <a name="express-intent"></a>明确意图

在前面的例子中更令人信服的用法是表示`Worker`参数可以是`null`，从而使空保护更合适。 如果在下面的示例中删除了 null 保护，编译器将警告您可能正在取消引用 null。 不管怎样，两个空防护仍然有效。

```csharp
public void DoWork(Worker? worker)
{
    // Guard against worker being null
    if (worker is null)
    {
        throw new ArgumentNullException(nameof(worker));
    }

    // Otherwise use worker argument
}
```

对于非公共 API（如完全由开发人员或开发团队控制的源代码），可取消的引用类型可以允许安全删除空防护，开发人员可以保证不需要。 此功能可以帮助处理警告，但它不能保证在运行时执行代码可能会导致 。 `NullReferenceException`

## <a name="breaking-changes"></a>中断性变更

非空警告是现有代码的明显突破更改，应附带选择加入机制。

更明显的是，在可消除性为隐式的特定方案中，来自可撤销类型的警告（如上所述）是对现有代码的一种重大更改：

* 无约束类型参数将被视为隐式空参数，因此将它们分配给`object`或访问这些参数`ToString`将产生警告。
* 如果类型推理推断表达式中的`null`空，则现有代码有时会生成空类型，而不是非空类型，这可能导致新的警告。

因此，可撤销的警告也需要可选

最后，向现有 API 添加注释对选择在警告中的用户升级库时将是一个重大更改。 这也是值得选择加入或退出的能力。"我想要错误修复，但我不准备处理它们的新注释"

总之，您需要能够选择加入/退出：
* 空警告
* 非空警告
* 来自其他文件中注释的警告

选择加入的粒度暗示了类似分析器的模型，其中大量代码可以选择使用实用模式输入和退出，用户可以选择严重性级别。 此外，每个库选项（"忽略JSON.NET注释，直到我准备好处理掉号"）可以在代码中作为属性表示。

选择加入/过渡体验的设计对于此功能的成功和有用性至关重要。 我们需要确保：

* 用户可以根据需要逐步采用无效检查
* 库作者可以添加空注释，而不必担心破坏客户
* 尽管如此，没有"配置噩梦"的感觉

## <a name="tweaks"></a>调整

我们可以考虑不使用局部变量的`?`注释，而只观察它们是否按照分配给他们的内容使用。 我不喜欢这样，我认为我们应该统一地让人们表达他们的意图。

我们可以考虑参数的速记`T! x`，即自动生成运行时空检查。

泛型类型（如`FirstOrDefault`或`TryGet`）上的某些模式具有具有非空类型参数的稍微奇怪的行为，因为它们在某些情况下显式生成默认值。 我们可以尝试对类型系统进行细微差别，以更好地适应这些类型系统。 例如，我们可以允许`?`无约束类型参数，即使类型参数已经为空。 我怀疑它是值得的，它导致与空*值*类型的交互相关的怪异。 

## <a name="nullable-value-types"></a>可以为 null 的值类型

我们可以考虑对空值类型采用上述一些语义。

我们已经提到类型推理，我们可以`int?`从`(7, null)`推断，而不是只给出一个错误。

另一个机会是将流分析应用于空值类型。 当它们被视为非空时，我们实际上可以允许以特定方式用作非空类型（例如成员访问）。 我们只需要小心，你*已经在*空值类型上可以做的事情将是首选的，因为背对了的原因。
